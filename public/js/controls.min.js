((tracery, baseEngModifiers, R) => {
  var traceryGrammar;
  
  const chunk = R.curry((n,xs) => R.isEmpty(xs) ? [] : [R.take(n)(xs), ...chunk(n) (R.drop (n) (xs))]);
  const arr = x => Array.from(x)
  const num = x => Number(x) || 0;
  const str = x => String(x)
  const numToWords = n => {
    const a = [
      '', 'one', 'two', 'three', 'four',
      'five', 'six', 'seven', 'eight', 'nine',
      'ten', 'eleven', 'twelve', 'thirteen', 'fourteen',
      'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'
    ];
    const b = [
      '', '', 'twenty', 'thirty', 'forty',
      'fifty', 'sixty', 'seventy', 'eighty', 'ninety'
    ];
    const g = [
      '', 'thousand', 'million', 'billion', 'trillion', 'quadrillion',
      'quintillion', 'sextillion', 'septillion', 'octillion', 'nonillion'
    ];
    // this part is really nasty still
    // it might edit this again later to show how Monoids could fix this up
    const makeGroup = ([ones,tens,huns]) => {
      return [
        num(huns) === 0 ? '' : a[huns] + ' hundred ',
        num(ones) === 0 ? b[tens] : b[tens] && b[tens] + '-' || '',
        a[tens+ones] || a[ones]
      ].join('');
    };
    // "thousands" constructor; no real good names for this, i guess
    const thousand = (group,i) => group === '' ? group : `${group} ${g[i]}`;
    // execute !
    if (typeof n === 'number') return numToWords(String(n));
    if (n === '0')             return 'zero';
    return R.trim(R.compose(chunk(3), R.reverse)(arr(n))
      .map(makeGroup)
      .map(thousand)
      .filter(R.compose(R.not, R.isEmpty))
      .reverse()
      .join(', '));
  };
  const lengthize = year => {
    const single = year => R.cond([
      [R.equals('one'), R.always('first')],
      [R.equals('two'), R.always('second')],
      [R.equals('three'), R.always('third')],
      [R.equals('five'), R.always('fifth')],
      [R.equals('eight'), R.always('eighth')],
      [R.equals('nine'), R.always('ninth')],
      [R.T, year => `${year}th`]
    ])(year)
    if(R.is(Number, year)) {
      year = numToWords(year);
    } else if(R.is(Number, parseInt(year))) {
      year = numToWords(parseInt(year));
    }
    if(year.match(/ty$/)) {
      year = year.replace(/ty$/,'tieth')
    } else{
      const found = year.match(/-(\S+)$/);
      if(found !== null) {
        year = year.replace(new RegExp(`-${found[1]}$`), `-${single(found[1])}`)
      } else {
        year = single(year);
      }
    }
    return year.replace(/hundred /, 'hundred and ');
  }
  
  // Better version of capitalize:
  baseEngModifiers.capitalize = R.compose(
    R.join(' '),
    R.map(x => R.compose(
      R.join(''),
      R.adjust(R.toUpper, 0)
    )(x)),
    R.split(' ')
  )
  var traceryModifiers = {
    lengthize,
    numToWords
  }

  function createStory() {
  	var numberOfStories = parseInt(document.querySelector('#numberOfStories').value);
  	var output = document.querySelector('#story');
  	
  	var stories = [];
  	for(var i=0;i<numberOfStories;i++) {
  		stories.push('<p>' + traceryGrammar.flatten('#origin#').replace(/\n\n/g,'</p><p>') + '</p>');
  	}
  	output.innerHTML = stories.join('<hr>');
  }
  function loadTracery(grammar) {
  	traceryGrammar = tracery.createGrammar(grammar);
  	traceryGrammar.addModifiers(baseEngModifiers);
    traceryGrammar.addModifiers(traceryModifiers);
  	createStory();
  	
  	document.querySelector('#newStory').addEventListener('click', function() {
  		createStory();
  	})
  }
  if(typeof GRAMMAR === 'undefined') {
  	GRAMMAR = JSON.parse(document.querySelector('#grammar').innerHTML);
  	loadTracery(GRAMMAR);
  } else if(typeof GRAMMAR === 'object') {
  	loadTracery(GRAMMAR);
  } else if(typeof GRAMMAR === 'string') {
  	var xhr = new XMLHttpRequest();
  	xhr.open('GET', GRAMMAR);
  	xhr.onload = function() {
  		if (xhr.status === 200) {
  			GRAMMAR = JSON.parse(xhr.responseText);
  			loadTracery(GRAMMAR);
  		}
  		else {
  			alert('Request failed.  Returned status of ' + xhr.status);
  		}
  	};
  	xhr.send();  
  }
})(tracery, baseEngModifiers, R)